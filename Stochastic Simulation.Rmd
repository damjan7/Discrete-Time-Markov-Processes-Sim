---
title: "Stochastic Simulation"
author: "Damjan Kostovic"
date: "5 3 2021"
output: pdf_document
---

Simulation of Transition Matrix as n -> infinity
```{r}
library(matrixcalc)

#Matrix 1
Transition_Matrix1 <- t(matrix(c(0.1,0.2,0.7,
                               0.9,0.1,0,
                               0.1,0.8,0.1), nrow = 3))
for (i in 1:15) {
  print(matrix.power(Transition_Matrix1,i))
}
print(matrix.power(Transition_Matrix1,200))

#Matrix 2
Transition_Matrix2 <- t(matrix(c(0,1,0,
                               0.3,0,0.7,
                               0,0,1), nrow = 3))
for (i in 1:12) {
  print(matrix.power(Transition_Matrix2,i))
}


#Matrix 3
Transition_Matrix3 <- t(matrix(c(0.7,0.3,
                               0.3,0.7), nrow = 2))
for (i in 1:5) {
  print(matrix.power(Transition_Matrix3,i))
}
```

Weather Prediction


Tennis Match

First, lets see if the initial probabilities really sum up to 1. (We'll try this by randomly generating p..);
```{r}
rm(list=ls())
initial.probs.func <- function(p,q){
  c0 <- q^4 + 4*q^4*p
  c1 <- 4*q^3*p^2
  c2 <- 6*q^2*p^2
  c3 <- 4*q^2*p^3
  c4 <- p^4+4*q*p^4
  
  return(c(c0,c1,c2,c3,c4))
}

set.seed(86351)
q = runif(1000,0,1)
p = 1-q

sum.of.probabilities <- numeric()
for (i in 1:1000){
  sum.of.probabilities[i] <- sum(inititial.probs.func(p[i],q[i]))
}

table(sum.of.probabilities)

```

Simulation of a game
```{r}
rm(list=ls())
initial.probs.func <- function(q,p){
  c0 <- q^4 + 4*q^4*p
  c1 <- 4*q^3*p^2
  c2 <- 6*q^2*p^2
  c3 <- 4*q^2*p^3
  c4 <- p^4+4*q*p^4
  
  return(c(c0,c1,c2,c3,c4))
}
T.MAT.func <- function(q,p){
  matrix(c(1,q,0,0,0,
           0,0,q,0,0,
           0,p,0,q,0,
           0,0,p,0,0,
           0,0,0,p,1),
         nrow = 5)
}


stage1.simfunc <- function(R){
  for (i in 1:40){
    q <- runif(1,0,1)
    p <- 1-q
    if (i == 1){
        stage1 <- rmultinom(1,R,initial.probs.func(q,p))
          df <- data.frame("Game B" = stage1[1],
           "Adv. B" = stage1[2],
           "Deuce" = stage1[3],
           "Adv. A" = stage1[4],
           "Game A" = stage1[5])
          rownames(df)[i] <- paste("q =", round(q,3))
    }
    else{
      stage1 <- rmultinom(1,R,initial.probs.func(q,p))
      df[i,1] = stage1[1]
      df[i,2] = stage1[2]
      df[i,3] = stage1[3]
      df[i,4] = stage1[4]
      df[i,5] = stage1[5]
      rownames(df)[i] <- paste("q =", round(q,3))
    }
  }
  return(df)
}
test <- stage1.simfunc(1000)

###Simulation of a whole game
set.seed(49519)

stage1.simfunc2 <- function(q,p){
  stage1 <- rmultinom(1,1,initial.probs.func(q,p))
  df <- data.frame("Game B" = stage1[1],
           "Adv. B" = stage1[2],
           "Deuce" = stage1[3],
           "Adv. A" = stage1[4],
           "Game A" = stage1[5])
  return(df)
}


###A win for Player B equals "1", so a total number of won 
###Games is easily calculated by sum(..)
Game_sim_func <- function(q,p){
  cur_state <- stage1.simfunc2(q,p)
  T.MAT <- T.MAT.func(q,p)
  cur_state_nr <- which(cur_state==1)
  duration<-1
while(TRUE){
  if (cur_state_nr == 1){
  print("Player B won!")
  return(c(1,duration))
  break
}else if(cur_state_nr == 5){
  print("Player A won!")
  return(c(0,duration))
}else if(cur_state_nr == 2){
  print("Player B is winning 40-30!")
  cur_state <- rmultinom(1,1, T.MAT[2,])
  cur_state_nr <- which(cur_state==1)
  duration <- duration + 1
}else if(cur_state_nr == 3){
  print("Deuce, 30-30!")
  cur_state <- rmultinom(1,1, T.MAT[3,])
  cur_state_nr <- which(cur_state==1)
  duration <- duration + 1
}
else if(cur_state_nr == 4){
  print("Player B is losing 30-40!")
  cur_state <- rmultinom(1,1, T.MAT[4,])
  cur_state_nr <- which(cur_state==1)
  duration <- duration + 1
}
}
}

tot.won.func <- function(nr_of_games, q,p, total.wins = 0){
  for (i in 1:nr_of_games){
      total.wins <- total.wins + Game_sim_func(q,p)
  }
  return(total.wins)
}


###Now we have a function to get total of wins
###now let's model the win-dependence of q
invisible(capture.output(tot.wins <- tot.won.func(100,0.6,0.4)))

set.seed(123812)
q <- ppoints(100)
tot.wins <- matrix(NA, ncol = 2, nrow = 100)
for (i in 1:100){
  invisible(capture.output(tot.wins[i,] <- tot.won.func(100,q[i],1-q[i])))
}

plot(q,tot.wins[,1], type = "l", main = "Wins for Player B for chaning win probability q", ylab = "Total wins for player B per 100 games",
     xlab="probability of winning a point for Player B")

plot(q, tot.wins[,2], type = "l", main="Length of the Random Walk Process [w/o Stage1]", xlab = "probability of winning a point for Player B",
     ylab = "Total of points played per 100 Games")


```


Now Let's write a function to see who wins a whole tennis match. We need a won games counter. I will not include a tiebreak. First to win 6 games, won the set

```{r}
Tennis.Match.Func <- function(q,p){
  wins.player.B <- 0
  wins.player.A <- 0
  sets.player.B <- 0
  sets.player.A <- 0
  
  while(TRUE){
  game <- Game_sim_func(q,p)[1]
  if (game == 1){
    print("Player B won the game!")
    writeLines("\n")
    wins.player.B <- wins.player.B + 1
    
    if (wins.player.B == 6){
      sets.player.B <- sets.player.B+1
      print(paste("Player B won the set! The total score in sets is: ", 
            sets.player.B, "to", sets.player.A, "for player B"))
      wins.player.B<-0
      wins.player.A<-0
    }
    if (sets.player.B == 2){
    print(paste("Player B won!! The final score is:",
             sets.player.B, "to", sets.player.A, "for player B"))
      break
    }
      
    
  }else{
    print("Player A won the game!")
    writeLines("\n")
    wins.player.A <- wins.player.A + 1
    if (wins.player.A == 6){
      sets.player.A <- sets.player.A+1
      print(paste("Player A won the set! The total score is: ", sets.player.B,
                  "to",
            sets.player.A, "for player B"))
      wins.player.B<-0
      wins.player.A<-0
    }
    if (sets.player.A == 2){
      print(paste("Player A won!! The final score is:",
             sets.player.A, "to", sets.player.B, "for player A"))
      break
    }
  }    
  }
}

Tennis.Match.Func(0.6,0.4)
```

